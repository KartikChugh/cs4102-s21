\documentclass[12pt]{article}
\usepackage[top=1in,bottom=1in,left=0.75in,right=0.75in,centering]{geometry}
\usepackage{fancyhdr}
\usepackage{epsfig}
\usepackage[pdfborder={0 0 0}]{hyperref}
\usepackage{palatino}
\usepackage{wrapfig}
\usepackage{lastpage}
\usepackage{color}
\usepackage{ifthen}
\usepackage[table]{xcolor}
\usepackage{graphicx,type1cm,eso-pic,color}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{wasysym}
\usepackage{latexsym}
\usepackage{amssymb}

\def\course{CS 4102: Algorithms}
\def\homework{Module 2 Advanced: Graph Proofs}
\def\semester{Spring 2021}

\newboolean{solution}
\setboolean{solution}{false}

% add watermark if it's a solution exam
% see http://jeanmartina.blogspot.com/2008/07/latex-goodie-how-to-watermark-things-in.html
\makeatletter
\AddToShipoutPicture{%
\setlength{\@tempdimb}{.5\paperwidth}%
\setlength{\@tempdimc}{.5\paperheight}%
\setlength{\unitlength}{1pt}%
\put(\strip@pt\@tempdimb,\strip@pt\@tempdimc){%
\ifthenelse{\boolean{solution}}{
\makebox(0,0){\rotatebox{45}{\textcolor[gray]{0.95}%
{\fontsize{5cm}{3cm}\selectfont{\textsf{Solution}}}}}%
}{}
}}
\makeatother

\pagestyle{fancy}

\fancyhf{}
\lhead{\course}
\chead{Page \thepage\ of \pageref{LastPage}}
\rhead{\semester}
%\cfoot{\Large (the bubble footer is automatically inserted into this space)}

\setlength{\headheight}{14.5pt}

\newenvironment{itemlist}{
\begin{itemize}
\setlength{\itemsep}{0pt}
\setlength{\parskip}{0pt}}
{\end{itemize}}

\newenvironment{numlist}{
\begin{enumerate}
\setlength{\itemsep}{0pt}
\setlength{\parskip}{0pt}}
{\end{enumerate}}

\newcounter{pagenum}
\setcounter{pagenum}{1}
\newcommand{\pageheader}[1]{
\clearpage\vspace*{-0.4in}\noindent{\large\bf{Page \arabic{pagenum}: {#1}}}
\addtocounter{pagenum}{1}
\cfoot{}
}

\newcounter{quesnum}
\setcounter{quesnum}{1}
\newcommand{\question}[2][??]{
\begin{list}{\labelitemi}{\leftmargin=2em}
\item [\arabic{quesnum}.] {#2}
\end{list}
\addtocounter{quesnum}{1}
}


\definecolor{red}{rgb}{1.0,0.0,0.0}
\newcommand{\answer}[2][??]{ 
\ifthenelse{\boolean{solution}}{
\color{red} #2 \color{black}}
{\vspace*{#1}}
}

\definecolor{blue}{rgb}{0.0,0.0,1.0}

\begin{document}

\section*{\homework}



%----------------------------------------------------------------------

\question[1]{
\emph{Kruskal's algorithm} begins by adding the smallest edge in the graph to the solution (and never looking back). Let $e=(u,v)$ be a minimum-weight edge in a connected graph $G$. Show that $e=(u,v)$ belongs to some minimum spanning tree of G. \emph{HINT: Use a proof by contradiction. Note that $e$ will eventually connect two smaller spanning trees together. If $e$ is NOT in the solution, than something else IS. Show that this leads to some kind of contradiction.}
}


%----------------------------------------------------------------------


\question[3]{
This problem is about robots that need to reach a particular destination. Suppose that you have an area represented by a graph $G = (V,E)$ and two robots with starting nodes $s_1, s_2 \in V$. Each robot also has a destination node $d_1,d_2 \in V$. Your task is to design a schedule of movements along edges in $G$ that move both robots to their respective destination nodes. You have the following constraints:

\begin{enumerate}
\item You must design a schedule for the robots. A schedule is a list of steps, where each step is an instruction for a single robot to move along a single edge.
\item If the two robots ever get close, then they will interfere with one another (perhaps start an epic robot fight?). Thus, you must design a schedule so that the robots, at no point in time, exist on the same or adjacent nodes.
\item You can assume that $s_1$ and $s_2$ are not the same or adjacent, and that the same is true for $d_1$ and $d_2$.
\end{enumerate}

Design an algorithm that produces an optimal schedule for the two robots. What is the runtime of your algorithm? How would the runtime change as the number of robots grows?
}


\question[3]{
This question is about the \emph{depth-first search tree} and \emph{breadth-first search tree} generated from a given \textbf{connected} graph $G$. Recall that these trees are formed by including the subset edges from $E$ that are traversed to first discover each node in the respective search. With this in mind, prove the following claim:

\emph{If $T_d$ is the depth-first search tree generated by running DFS on $G$ rooted at some node $u$, and $T_b$ is the breadth-first search tree generated by running BFS on $G$ rooted at that same node $u$, then $T_d=T_b \to G=T_d=T_b$. In other words, if BFS and DFS produce the same tree, then the entire graph $G$ was already a tree.}

\textbf{Hint:} Try proving this by induction on $G$. When $G$ is just one node, the claim is pretty trivial. What if $G$ is two nodes? Three nodes? etc.
}




\end{document}
